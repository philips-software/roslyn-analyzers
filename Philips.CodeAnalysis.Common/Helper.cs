// © 2019 Koninklijke Philips N.V. See License.md in the project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Philips.CodeAnalysis.Common
{
	internal static class Helper
	{
		private static bool HasGeneratedCodeAttribute(SyntaxNodeAnalysisContext context, SyntaxNode node)
		{
			while (node != null)
			{
				SyntaxList<AttributeListSyntax> attributes;
				switch (node)
				{
					case ClassDeclarationSyntax cls:
						attributes = cls.AttributeLists;
						break;
					case StructDeclarationSyntax st:
						attributes = st.AttributeLists;
						break;
					case MethodDeclarationSyntax method:
						attributes = method.AttributeLists;
						break;
					default:
						node = node.Parent;
						continue;
				}

				if (HasAttribute(attributes, context, "GeneratedCode", "System.CodeDom.Compiler.GeneratedCodeAttribute", out Location location))
				{
					return true;
				}

				node = node.Parent;
			}

			return false;
		}

		public static string ToDiagnosticId(DiagnosticIds id)
		{
			return @"PH" + ((int)id).ToString();
		}

		public static bool IsInTestClass(SyntaxNodeAnalysisContext context)
		{
			return IsInTestClass(context, out _);
		}

		public static bool IsInTestClass(SyntaxNodeAnalysisContext context, out ClassDeclarationSyntax classDeclaration)
		{
			classDeclaration = context.Node.FirstAncestorOrSelf<ClassDeclarationSyntax>();
			if (classDeclaration == null)
			{
				return false;
			}
			SyntaxList<AttributeListSyntax> classAttributeList = classDeclaration.AttributeLists;
			return Helper.HasAttribute(classAttributeList, context, MsTestFrameworkDefinitions.TestClassAttribute, out Location descriptionLocation);
		}

		public static bool IsTestClass(ClassDeclarationSyntax classDeclaration, SyntaxNodeAnalysisContext context)
		{
			SyntaxList<AttributeListSyntax> classAttributeList = classDeclaration.AttributeLists;
			return Helper.HasAttribute(classAttributeList, context, MsTestFrameworkDefinitions.TestClassAttribute, out Location descriptionLocation);
		}

		public static bool HasInterface(ITypeSymbol typeConstructed, string interfaceName, string interfaceAssembly)
		{
			IEnumerable<INamedTypeSymbol> itsInterfaces = typeConstructed?.AllInterfaces;
			if (itsInterfaces == null)
			{
				return false;
			}

			foreach (INamedTypeSymbol itsInterface in itsInterfaces)
			{
				if (itsInterface.Name == interfaceName && itsInterface.ContainingAssembly.Name == interfaceAssembly)
				{
					return true;
				}
			}

			return false;
		}

		/// <summary>
		/// Checks for the presence of an "autogenerated" comment in the starting trivia for a file
		/// The compiler generates a version of the AssemblyInfo.cs file for certain projects (not named AssemblyInfo.cs), and this is how to pick it up
		/// </summary>
		/// <param name="node"></param>
		/// <returns></returns>
		public static bool HasAutoGeneratedComment(CompilationUnitSyntax node)
		{
			if (node.FindToken(0).IsKind(SyntaxKind.EndOfFileToken))
			{
				return false;
			}

			var first = node.GetLeadingTrivia();

			if (first.Count == 0)
			{
				return false;
			}

			string possibleHeader = first.ToFullString();


			bool isAutogenerated = possibleHeader.Contains(@"<autogenerated />") || possibleHeader.Contains("<auto-generated");

			return isAutogenerated;
		}

		public static bool HasAnyAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, params AttributeDefinition[] attributes)
		{
			return attributes.Any(x => HasAttribute(attributeLists, context, x));
		}

		public static bool HasAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, AttributeDefinition attribute)
		{
			return HasAttribute(attributeLists, context, attribute.Name, attribute.FullName, out _);
		}

		public static bool HasAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, AttributeDefinition attribute, out Location location)
		{
			return HasAttribute(attributeLists, context, attribute.Name, attribute.FullName, out location);
		}

		public static bool HasAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, string name, string fullName)
		{
			return HasAttribute(attributeLists, context, name, fullName, out _);
		}

		public static bool HasAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, string name, string fullName, out Location location)
		{
			location = null;
			return HasAttribute(attributeLists, context, name, fullName, out location, out _);
		}

		public static bool HasAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, AttributeDefinition attributeDefinition, out Location location, out string argumentValue)
		{
			argumentValue = string.Empty;
			if (HasAttribute(attributeLists, context, attributeDefinition.Name, attributeDefinition.FullName, out location, out AttributeArgumentSyntax argument))
			{
				argumentValue = argument.ToString();

				return true;
			}

			return false;
		}

		public static bool HasAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, AttributeDefinition attributeDefinition, out Location location, out AttributeArgumentSyntax argument)
		{
			return HasAttribute(attributeLists, context, attributeDefinition.Name, attributeDefinition.FullName, out location, out argument);
		}

		public static bool HasAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, string name, string fullName, out Location location, out AttributeArgumentSyntax argumentValue)
		{
			location = null;
			argumentValue = default(AttributeArgumentSyntax);
			if (attributeLists == null)
			{
				return false;
			}
			foreach (AttributeListSyntax attributes in attributeLists)
			{
				if (HasAttribute(attributes, context, name, fullName, out location, out argumentValue))
				{
					return true;
				}
			}
			return false;
		}

		public static bool HasAttribute(AttributeListSyntax attributes, SyntaxNodeAnalysisContext context, AttributeDefinition attributeDefinition, out Location location)
		{
			return HasAttribute(attributes, context, attributeDefinition.Name, attributeDefinition.FullName, out location);
		}

		public static bool HasAttribute(AttributeListSyntax attributes, SyntaxNodeAnalysisContext context, string name, string fullName, out Location location)
		{
			location = null;
			foreach (AttributeSyntax attribute in attributes.Attributes)
			{
				if (attribute.Name.ToString().Contains(name))
				{
					IMethodSymbol memberSymbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol as IMethodSymbol;
					if (memberSymbol != null && memberSymbol.ToString().StartsWith(fullName))
					{
						location = attribute.GetLocation();
						return true;
					}
				}
			}
			return false;
		}

		public static bool TryGetAttribute(SyntaxList<AttributeListSyntax> attributeLists, SyntaxNodeAnalysisContext context, AttributeDefinition attributeDefinition, out AttributeSyntax attribute)
		{
			foreach (AttributeListSyntax syntax in attributeLists)
			{
				if (TryGetAttribute(syntax, context, attributeDefinition, out attribute))
				{
					return true;
				}
			}

			attribute = default;
			return false;
		}

		public static bool TryGetAttribute(AttributeListSyntax attributes, SyntaxNodeAnalysisContext context, AttributeDefinition attributeDefinition, out AttributeSyntax attribute)
		{
			foreach (AttributeSyntax attr in attributes.Attributes)
			{
				if (attr.Name.ToString().Contains(attributeDefinition.Name))
				{
					IMethodSymbol memberSymbol = context.SemanticModel.GetSymbolInfo(attr).Symbol as IMethodSymbol;
					if (memberSymbol != null && memberSymbol.ToString().StartsWith(attributeDefinition.FullName))
					{
						attribute = attr;
						return true;
					}
				}
			}

			attribute = default;
			return false;
		}

		public static bool HasAttribute(AttributeListSyntax attributes, SyntaxNodeAnalysisContext context, string name, string fullName, out Location location, out AttributeArgumentSyntax argument)
		{
			location = null;
			argument = default(AttributeArgumentSyntax);
			foreach (AttributeSyntax attribute in attributes.Attributes)
			{
				if (IsAttribute(attribute, context, name, fullName, out location, out argument))
				{
					return true;
				}
			}

			return false;
		}

		public static bool IsAttribute(AttributeSyntax attribute, SyntaxNodeAnalysisContext context, string name, string fullName, out Location location, out AttributeArgumentSyntax argument)
		{
			location = null;
			argument = default(AttributeArgumentSyntax);

			if (attribute.Name.ToString().Contains(name))
			{
				IMethodSymbol memberSymbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol as IMethodSymbol;
				if (memberSymbol != null && memberSymbol.ToString().StartsWith(fullName))
				{
					location = attribute.GetLocation();
					if (attribute.ArgumentList != null && attribute.ArgumentList.Arguments.Count > 0)
					{
						argument = attribute.ArgumentList.Arguments.First();
					}
					return true;
				}
			}

			return false;
		}
		public static bool IsAttribute(AttributeSyntax attribute, SyntaxNodeAnalysisContext context, AttributeDefinition attributeDefinition, out Location location, out AttributeArgumentSyntax argument)
		{
			return IsAttribute(attribute, context, attributeDefinition.Name, attributeDefinition.FullName, out location, out argument);
		}

		public static bool IsDataRowAttribute(AttributeSyntax attribute, SyntaxNodeAnalysisContext context)
		{
			return IsAttribute(attribute, context, MsTestFrameworkDefinitions.DataRowAttribute, out _, out _);
		}

		public static bool IsDataTestMethod(SyntaxList<AttributeListSyntax> attributes, SyntaxNodeAnalysisContext context)
		{
			return attributes.Any(x => HasAttribute(attributes, context, MsTestFrameworkDefinitions.DataTestMethodAttribute, out _));
		}

		public static bool IsTestMethod(SyntaxList<AttributeListSyntax> attributes, SyntaxNodeAnalysisContext context)
		{
			return IsTestMethod(attributes, context, out _);
		}

		public static bool IsTestMethod(MethodDeclarationSyntax method, SyntaxNodeAnalysisContext context)
		{
			return IsTestMethod(method.AttributeLists, context, out _);
		}

		public static bool IsTestMethod(SyntaxList<AttributeListSyntax> attributes, SyntaxNodeAnalysisContext context, out bool isDataTestMethod)
		{
			foreach (AttributeListSyntax syntax in attributes)
			{
				if (IsTestMethod(syntax, context, out _, out isDataTestMethod))
				{
					return true;
				}
			}

			isDataTestMethod = false;
			return false;
		}

		public static bool IsTestMethod(AttributeListSyntax attributes, SyntaxNodeAnalysisContext context, out Location location)
		{
			return IsTestMethod(attributes, context, out location, out _);
		}

		public static bool IsTestMethod(AttributeListSyntax attributes, SyntaxNodeAnalysisContext context, out Location location, out bool isDataTestMethod)
		{
			isDataTestMethod = false;
			bool returnValue = HasAttribute(attributes, context, MsTestFrameworkDefinitions.TestMethodAttribute, out location);
			if (!returnValue)
			{
				returnValue = HasAttribute(attributes, context, MsTestFrameworkDefinitions.DataTestMethodAttribute, out location);

				if (returnValue)
				{
					isDataTestMethod = true;
				}
			}
			return returnValue;
		}

		public static bool IsTestMethod(AttributeListSyntax attributes, SyntaxNodeAnalysisContext context)
		{
			Location location;
			return IsTestMethod(attributes, context, out location);
		}


		public static bool IsConstantExpression(ExpressionSyntax expression, SemanticModel semanticModel)
		{
			// this assumes you've already checked for literals

			MemberAccessExpressionSyntax memberAccess = expression as MemberAccessExpressionSyntax;
			if (memberAccess != null)
			{
				// return true for member accesses that resolve to a constant e.g. SurveillanceConstants.TrendWidth
				Optional<object> constValue = semanticModel.GetConstantValue(expression);
				return constValue.HasValue;
			}
			else
			{
				TypeOfExpressionSyntax typeOfExpression = expression as TypeOfExpressionSyntax;
				if (typeOfExpression != null)
				{
					if (typeOfExpression.Type is PredefinedTypeSyntax)
					{
						// return true for typeof(<static type>)
						return true;
					}
				}
			}

			return false;
		}

		public static bool IsGeneratedCode(SyntaxNodeAnalysisContext context)
		{
			string myFilePath = context.Node.SyntaxTree.FilePath;

			return IsGeneratedCode(myFilePath) || HasGeneratedCodeAttribute(context, context.Node);
		}

		public static bool IsGeneratedCode(string filePath)
		{
			string fileName = GetFileName(filePath);

			return fileName.EndsWith(@".Designer.cs", StringComparison.OrdinalIgnoreCase);
		}

		private static string GetFileName(string filePath)
		{
			string[] nodes = filePath.Split('/', '\\');
			return nodes[nodes.Length - 1];
		}

		public static bool IsAssemblyInfo(SyntaxNodeAnalysisContext context)
		{
			string fileName = GetFileName(context.Node.SyntaxTree.FilePath);

			return fileName.EndsWith("AssemblyInfo.cs", StringComparison.OrdinalIgnoreCase);
		}

		public static bool IsInheritingFromClass(INamedTypeSymbol type, string classTypeName)
		{
			while (type != null)
			{
				if (type.Name == classTypeName)
				{
					return true;
				}
				type = type.BaseType;
			}

			return false;
		}

		public static bool IsUserControl(INamedTypeSymbol type)
		{
			return IsInheritingFromClass(type, @"ContainerControl");
		}

		public static bool IsLiteralTrueFalse(ExpressionSyntax expressionSyntax)
		{
			var kind = expressionSyntax.Kind();
			switch (kind)
			{
				case SyntaxKind.LogicalNotExpression:
					//recurse.
					return IsLiteralTrueFalse(((PrefixUnaryExpressionSyntax)expressionSyntax).Operand);

				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
					//literal true/false
					return true;
				default:
					return false;
			}
		}
	}
}
