# PH2045: Avoid static classes

| Property | Value  |
|--|--|
| Package | [Philips.CodeAnalysis.MaintainabilityAnalyzers](https://www.nuget.org/packages/Philips.CodeAnalysis.MaintainabilityAnalyzers) |
| Diagnostic ID | PH2045 |
| Category  | [Maintainability](../Maintainability.md) |
| Analyzer | [AvoidStaticClassesAnalyzer](https://github.com/philips-software/roslyn-analyzers/blob/main/Philips.CodeAnalysis.MaintainabilityAnalyzers/Maintainability/AvoidStaticClassesAnalyzer.cs)
| CodeFix  | Yes |
| Severity | Error |
| Enabled By Default | Yes |

## Introduction

Static classes complicate Unit Testing because they cannot be easily mocked or substituted. This analyzer flags static classes that contain executable code to encourage better testable design patterns.

## Allowed Static Classes

The following types of static classes are **allowed** and will not trigger this diagnostic:

1. **Static classes containing only constant fields**: Classes with only `const` fields and `static readonly` fields
2. **Built-in exceptions**: The analyzer automatically excludes:
   - `*.Startup` classes (ASP.NET Core startup classes)
   - `*.Program` classes (program entry points)
   - `*.AssemblyInitialize` classes (test initialization)
3. **Extension method classes**: Classes containing only extension methods
4. **Whitelisted classes**: Classes listed in `StaticClasses.Allowed.txt`

## What Triggers the Diagnostic

Static classes containing any of the following executable members will trigger this diagnostic:
- Methods (except extension methods)
- Properties with getters/setters
- Static constructors
- Events (both explicit and field-like declarations)
- Indexers

## How to solve

Migrate into an instance class or singleton pattern to improve testability.

## Example

Code that triggers a diagnostic:
``` cs
static class BadExample
{
    public static void DoSomething()
    {
        // Executable method - triggers diagnostic
    }
    
    public static int Property { get; set; }  // Property - triggers diagnostic
}

static class AlsoBadExample
{
    public const int Value = 200;
    public static int Property { get; } = 1200;  // Contains executable code - triggers diagnostic
}
```

Code that does **not** trigger a diagnostic:
``` cs
static class AllowedExample
{
    public const int Value = 200;
    public static readonly int ReadOnlyValue = 300;
    // Only constants - allowed
}

static class ExtensionMethodsExample
{
    public static void DoSomething(this SomeType obj)
    {
        // Extension methods are allowed
    }
}
```

Recommended replacement code:
``` cs
class GoodExample
{
    public void DoSomething()
    {
        // Now testable with mocking
    }
    
    public int Property { get; set; }
}

// Or use singleton pattern if global state is needed
class SingletonExample
{
    private static readonly Lazy<SingletonExample> _instance = new(() => new SingletonExample());
    public static SingletonExample Instance => _instance.Value;
    
    private SingletonExample() { }
    
    public void DoSomething() { }
}
```

## Configuration

This rule supports a whitelist, one class per line, in a file named `StaticClasses.Allowed.txt` in the project marked as an &lt;AdditionalFile&gt;.

The general ways of [suppressing](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/suppress-warnings) diagnostics apply.
