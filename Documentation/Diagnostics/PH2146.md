# PH2146: Avoid problematic using statement patterns

| Property | Value  |
|--|--|
| Package | [Philips.CodeAnalysis.MaintainabilityAnalyzers](https://www.nuget.org/packages/Philips.CodeAnalysis.MaintainabilityAnalyzers) |
| Diagnostic ID | PH2146 |
| Category  | [Maintainability](../Maintainability.md) |
| Analyzer | [AvoidProblematicUsingPatternsAnalyzer](https://github.com/philips-software/roslyn-analyzers/blob/main/Philips.CodeAnalysis.MaintainabilityAnalyzers/Maintainability/AvoidProblematicUsingPatternsAnalyzer.cs)
| CodeFix  | No |
| Severity | Warning |
| Enabled By Default | No |

## Introduction

This rule flags `using` statements that use fields, member access expressions, or local variables, which can lead to double disposal or ownership issues.

## Reason

Using statements with fields or variables can be problematic because they may dispose objects that are already being managed elsewhere, potentially causing:

- Double disposal exceptions when the object is disposed both by the using statement and by other code
- Access to disposed objects if the field/variable is used after the using block
- Unclear ownership semantics where multiple parts of code think they own the object

## How to fix violations

Replace problematic using patterns with safer alternatives:

- Create new objects directly in the using statement
- Call methods that return disposable objects
- Use parameters instead of fields when possible
- Consider refactoring the design to have clearer ownership semantics

## Examples

### Incorrect

```csharp
class BadExample
{
    private Stream _stream = new MemoryStream();
    
    public void BadMethod()
    {
        // Direct field usage - may lead to double disposal
        using (_stream)
        {
            // Do something
        }
        
        // Field assignment to using variable
        using (var localStream = _stream)
        {
            // Do something
        }
        
        // Member access expression
        using (this.Stream)
        {
            // Do something
        }
        
        // Local variable reuse
        Stream existingStream = new MemoryStream();
        using (var localStream = existingStream)
        {
            // Do something
        }
    }
}
```

### Correct

```csharp
class GoodExample
{
    public void GoodMethod(Stream inputParameter)
    {
        // Create new object directly - safe
        using (var stream = new MemoryStream())
        {
            // Do something
        }
        
        // Method call that returns disposable - safe
        using (var stream = CreateStream())
        {
            // Do something
        }
        
        // Using parameter - safe (caller owns the object)
        using (var stream = inputParameter)
        {
            // Do something
        }
    }
    
    private Stream CreateStream()
    {
        return new MemoryStream();
    }
}
```